//! Event-driven subgraph executor implementation.
//!
//! The `EventSubgraphExecutor` processes events in chronological order,
//! calling each node's `on_event()` method when events arrive for that node.

use std::collections::{BTreeMap, HashMap};

use crate::event::{Event, EventPayload};
use crate::executor::SubgraphExecutor;
use crate::node::Node;
use crate::types::{NodeId, SimTime, SubgraphId};

/// A priority queue for events, ordered by time.
///
/// Uses `BTreeMap` to maintain events in chronological order.
/// Events at the same time are processed in insertion order (FIFO).
#[derive(Debug, Default)]
pub struct EventQueue {
    /// Events organized by time, with a secondary counter for stable ordering
    queue: BTreeMap<(SimTime, u64), Event>,
    /// Counter for maintaining insertion order at the same timestamp
    counter: u64,
}

impl EventQueue {
    /// Creates a new empty event queue.
    pub fn new() -> Self {
        Self {
            queue: BTreeMap::new(),
            counter: 0,
        }
    }

    /// Inserts an event into the queue.
    pub fn push(&mut self, event: Event) {
        let key = (event.time, self.counter);
        self.counter += 1;
        self.queue.insert(key, event);
    }

    /// Inserts multiple events into the queue.
    pub fn push_all(&mut self, events: impl IntoIterator<Item = Event>) {
        for event in events {
            self.push(event);
        }
    }

    /// Removes and returns the earliest event, if any.
    pub fn pop(&mut self) -> Option<Event> {
        self.queue.pop_first().map(|(_, event)| event)
    }

    /// Returns a reference to the earliest event without removing it.
    pub fn peek(&self) -> Option<&Event> {
        self.queue.first_key_value().map(|(_, event)| event)
    }

    /// Returns the time of the earliest event, if any.
    pub fn peek_time(&self) -> Option<SimTime> {
        self.peek().map(|e| e.time)
    }

    /// Returns true if the queue is empty.
    pub fn is_empty(&self) -> bool {
        self.queue.is_empty()
    }

    /// Returns the number of events in the queue.
    pub fn len(&self) -> usize {
        self.queue.len()
    }

    /// Clears all events from the queue.
    pub fn clear(&mut self) {
        self.queue.clear();
        self.counter = 0;
    }

    /// Removes and returns all events with time <= target.
    pub fn drain_until(&mut self, target: SimTime) -> Vec<Event> {
        let mut events = Vec::new();
        while let Some(time) = self.peek_time() {
            if time <= target {
                if let Some(event) = self.pop() {
                    events.push(event);
                }
            } else {
                break;
            }
        }
        events
    }
}

/// Statistics collected by the event executor.
#[derive(Clone, Debug, Default)]
pub struct EventExecutorStats {
    /// Total number of events processed
    pub events_processed: u64,
    /// Total number of events generated by nodes
    pub events_generated: u64,
    /// Total number of incoming events from other subgraphs
    pub incoming_events: u64,
    /// Total number of outgoing events to other subgraphs
    pub outgoing_events: u64,
    /// Peak queue size observed
    pub peak_queue_size: usize,
}

/// An event-driven subgraph executor.
///
/// This executor:
/// - Maintains an event priority queue ordered by time
/// - Processes events in chronological order
/// - Calls the appropriate node's `on_event()` for each event
/// - Collects new events generated by nodes
pub struct EventSubgraphExecutor {
    /// Unique identifier for this subgraph
    id: SubgraphId,
    /// Current simulation time
    current_time: SimTime,
    /// Nodes in this subgraph, stored by their ID
    nodes: HashMap<NodeId, Box<dyn Node>>,
    /// The event priority queue
    event_queue: EventQueue,
    /// Statistics
    stats: EventExecutorStats,
}

impl EventSubgraphExecutor {
    /// Creates a new event-driven executor.
    pub fn new(id: SubgraphId) -> Self {
        Self {
            id,
            current_time: 0,
            nodes: HashMap::new(),
            event_queue: EventQueue::new(),
            stats: EventExecutorStats::default(),
        }
    }

    /// Adds a node to this executor.
    pub fn add_node(&mut self, id: NodeId, node: Box<dyn Node>) {
        self.nodes.insert(id, node);
    }

    /// Schedules an event for processing.
    ///
    /// The event will be processed when `run_until()` is called with
    /// a target time >= the event's time.
    pub fn schedule_event(&mut self, event: Event) {
        self.event_queue.push(event);
        self.update_peak_queue_size();
    }

    /// Schedules multiple events for processing.
    pub fn schedule_events(&mut self, events: impl IntoIterator<Item = Event>) {
        for event in events {
            self.schedule_event(event);
        }
    }

    /// Returns the number of pending events.
    pub fn pending_event_count(&self) -> usize {
        self.event_queue.len()
    }

    /// Processes a single event.
    ///
    /// Returns (local_events, outgoing_events) where:
    /// - local_events: events destined for nodes in this subgraph
    /// - outgoing_events: events destined for other subgraphs
    fn process_event(&mut self, event: Event) -> (Vec<Event>, Vec<Event>) {
        self.stats.events_processed += 1;

        // Update current time to event time
        if event.time > self.current_time {
            self.current_time = event.time;
        }

        // Find the destination node
        let dst_node_id = match &event.payload {
            EventPayload::Message { dst, .. } => Some(dst.0),
            EventPayload::Custom(_) => None,
        };

        let mut local_events = Vec::new();
        let mut outgoing_events = Vec::new();

        if let Some(node_id) = dst_node_id {
            if let Some(node) = self.nodes.get_mut(&node_id) {
                let new_events = node.on_event(event);
                self.stats.events_generated += new_events.len() as u64;

                // Separate local vs outgoing events
                for new_event in new_events {
                    if let Some(dst_id) = new_event.payload.dst_node() {
                        if self.nodes.contains_key(&dst_id) {
                            local_events.push(new_event);
                        } else {
                            outgoing_events.push(new_event);
                        }
                    } else {
                        // Custom events are treated as outgoing
                        outgoing_events.push(new_event);
                    }
                }
            }
        }

        (local_events, outgoing_events)
    }

    fn update_peak_queue_size(&mut self) {
        let current_size = self.event_queue.len();
        if current_size > self.stats.peak_queue_size {
            self.stats.peak_queue_size = current_size;
        }
    }

    /// Returns a reference to a node by ID.
    pub fn get_node(&self, id: NodeId) -> Option<&Box<dyn Node>> {
        self.nodes.get(&id)
    }

    /// Returns a mutable reference to a node by ID.
    pub fn get_node_mut(&mut self, id: NodeId) -> Option<&mut Box<dyn Node>> {
        self.nodes.get_mut(&id)
    }
}

impl SubgraphExecutor for EventSubgraphExecutor {
    fn id(&self) -> SubgraphId {
        self.id
    }

    fn init(&mut self) {
        self.current_time = 0;
        self.event_queue.clear();
        self.stats = EventExecutorStats::default();

        // Initialize all nodes
        for node in self.nodes.values_mut() {
            node.init();
        }
    }

    fn handle_incoming(&mut self, events: Vec<Event>) {
        self.stats.incoming_events += events.len() as u64;
        self.schedule_events(events);
    }

    fn run_until(&mut self, target: SimTime) -> Vec<Event> {
        let mut all_outgoing = Vec::new();

        // Process events until we've handled all events <= target
        while let Some(time) = self.event_queue.peek_time() {
            if time > target {
                break;
            }

            if let Some(event) = self.event_queue.pop() {
                let (local_events, outgoing_events) = self.process_event(event);

                // Schedule local events for processing
                self.schedule_events(local_events);

                // Collect outgoing events
                self.stats.outgoing_events += outgoing_events.len() as u64;
                all_outgoing.extend(outgoing_events);
            }
        }

        // Advance time to target even if no events
        if target > self.current_time {
            self.current_time = target;
        }

        all_outgoing
    }

    fn export_stats(&self) -> serde_json::Value {
        serde_json::json!({
            "subgraph_id": self.id,
            "current_time": self.current_time,
            "events_processed": self.stats.events_processed,
            "events_generated": self.stats.events_generated,
            "incoming_events": self.stats.incoming_events,
            "outgoing_events": self.stats.outgoing_events,
            "peak_queue_size": self.stats.peak_queue_size,
            "pending_events": self.event_queue.len(),
        })
    }

    fn current_time(&self) -> SimTime {
        self.current_time
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nodes::mock::{CounterNode, EchoNode};

    #[test]
    fn test_event_queue_basic() {
        let mut queue = EventQueue::new();

        queue.push(Event::custom(30, "third"));
        queue.push(Event::custom(10, "first"));
        queue.push(Event::custom(20, "second"));

        // Events should come out in time order
        assert_eq!(queue.pop().unwrap().time, 10);
        assert_eq!(queue.pop().unwrap().time, 20);
        assert_eq!(queue.pop().unwrap().time, 30);
        assert!(queue.pop().is_none());
    }

    #[test]
    fn test_event_queue_same_time_fifo() {
        let mut queue = EventQueue::new();

        queue.push(Event::custom(10, "first"));
        queue.push(Event::custom(10, "second"));
        queue.push(Event::custom(10, "third"));

        // Events at same time should maintain insertion order
        if let EventPayload::Custom(s) = &queue.pop().unwrap().payload {
            assert_eq!(s, "first");
        }
        if let EventPayload::Custom(s) = &queue.pop().unwrap().payload {
            assert_eq!(s, "second");
        }
        if let EventPayload::Custom(s) = &queue.pop().unwrap().payload {
            assert_eq!(s, "third");
        }
    }

    #[test]
    fn test_event_queue_drain_until() {
        let mut queue = EventQueue::new();

        queue.push(Event::custom(10, "a"));
        queue.push(Event::custom(20, "b"));
        queue.push(Event::custom(30, "c"));
        queue.push(Event::custom(40, "d"));

        let drained = queue.drain_until(25);
        assert_eq!(drained.len(), 2);
        assert_eq!(drained[0].time, 10);
        assert_eq!(drained[1].time, 20);

        // Remaining events
        assert_eq!(queue.len(), 2);
        assert_eq!(queue.peek_time(), Some(30));
    }

    #[test]
    fn test_event_executor_creation() {
        let exec = EventSubgraphExecutor::new(1);
        assert_eq!(exec.id(), 1);
        assert_eq!(exec.current_time(), 0);
        assert_eq!(exec.pending_event_count(), 0);
    }

    #[test]
    fn test_event_executor_basic_processing() {
        let mut exec = EventSubgraphExecutor::new(1);

        let node = CounterNode::new(100);
        exec.add_node(100, Box::new(node));
        exec.init();

        // Schedule some events
        exec.schedule_event(Event::message(10, 1, "out", 100, "in", serde_json::json!({})));
        exec.schedule_event(Event::message(20, 1, "out", 100, "in", serde_json::json!({})));

        assert_eq!(exec.pending_event_count(), 2);

        // Process events
        let outgoing = exec.run_until(25);
        assert!(outgoing.is_empty()); // CounterNode doesn't generate events

        let stats = exec.export_stats();
        assert_eq!(stats["events_processed"], 2);
    }

    #[test]
    fn test_event_executor_time_advancement() {
        let mut exec = EventSubgraphExecutor::new(1);
        exec.init();

        // No events, but time should advance
        exec.run_until(100);
        assert_eq!(exec.current_time(), 100);

        // Schedule event in the future
        exec.schedule_event(Event::custom(150, "future"));
        exec.run_until(120);

        // Time advances but event not processed yet
        assert_eq!(exec.current_time(), 120);
        assert_eq!(exec.pending_event_count(), 1);

        // Now process the future event
        exec.run_until(160);
        assert_eq!(exec.current_time(), 160);
        assert_eq!(exec.pending_event_count(), 0);
    }

    #[test]
    fn test_event_executor_echo_chain() {
        let mut exec = EventSubgraphExecutor::new(1);

        // Create two echo nodes that ping-pong
        // Node 100 echoes to node 200, node 200 echoes to node 100
        let echo1 = EchoNode::new(100, 10);
        let echo2 = EchoNode::new(200, 10);

        exec.add_node(100, Box::new(echo1));
        exec.add_node(200, Box::new(echo2));
        exec.init();

        // Start with an event to node 100
        exec.schedule_event(Event::message(
            0,
            200,
            "echo_out",
            100,
            "in",
            serde_json::json!({"ping": 1}),
        ));

        // Run and observe the chain reaction
        // t=0: event arrives at 100
        // t=10: 100 echoes back to 200
        // t=20: 200 echoes back to 100
        // etc.
        exec.run_until(25);

        let stats = exec.export_stats();
        // At least 3 events should have been processed (initial + 2 echoes)
        assert!(stats["events_processed"].as_u64().unwrap() >= 3);
    }

    #[test]
    fn test_handle_incoming() {
        let mut exec = EventSubgraphExecutor::new(1);
        exec.add_node(100, Box::new(CounterNode::new(100)));
        exec.init();

        let events = vec![
            Event::message(10, 1, "out", 100, "in", serde_json::json!({})),
            Event::message(20, 1, "out", 100, "in", serde_json::json!({})),
        ];

        exec.handle_incoming(events);

        assert_eq!(exec.pending_event_count(), 2);

        let stats = exec.export_stats();
        assert_eq!(stats["incoming_events"], 2);
    }
}

